function initTailHeadIndices(obj)
%
%
%   seg_worm.worm.contour.initTailHeadIndices


%TODO: Incorporate pe below
%pe = seg_worm.parse_error();

% % USE_MAX = true;
% % LF_ANGLE_CUTOFF = 90;
% % HF_ANGLE_CUTOFF = 60;
% % 
% % %Compute the contour's local high/low-frequency curvature maxima.
% % [hf_HT_max_peaks,hf_HT_I] = obj.getLocalPeaksOfAngles('hf_angles_smoothed',USE_MAX,HF_ANGLE_CUTOFF);
% % [lf_HT_max_peaks,lf_HT_I] = obj.getLocalPeaksOfAngles('lf_angles',USE_MAX,LF_ANGLE_CUTOFF);

keyboard

hf_HT_I = obj.hf_ap_max_I(obj.hf_ap_max_I

n_hf_HT_I = length(hf_HT_I);
n_lf_HT_I = length(lf_HT_I);

%ERRORS
%--------------------------------------------------------------------------
% Are there too many possible head/tail points?
if n_lf_HT_I > 2
    obj.parse_error = true;
    obj.error_num = 104;
    obj.error_msg = ['The worm has 3 or more low-frequency sampled convexities' ...
        'sharper than 90 degrees (possible head/tail points).'];
    return
end

if n_hf_HT_I < 2
    obj.parse_error = true;
    obj.error_num = 105;
    obj.error_msg = ['The worm contour has less than 2 high-frequency sampled '...
        'convexities sharper than 60 degrees (the head and tail). ' ...
        'Therefore, the worm is coiled or obscured and cannot be segmented.'];
    return
end

%--------------------------------------------------------------------------
if n_lf_HT_I > 1
    [head_I,tail_I] = helper__getHeadTailByLF(obj,lf_HT_max_peaks,lf_HT_I,hf_HT_I);
elseif n_hf_HT_I < 3
    % The high-frequency sampling identifies the head and tail.
    [head_I,tail_I] = helper__getHeadTailByHF(hf_HT_max_peaks,hf_HT_I);
else
    % The high-frequency sampling identifies several, potential heads/tails.
    [head_I,tail_I] = helper__getHeadTailByManyHF;
end

obj.head_I = head_I;
obj.tail_I = tail_I;

cc_lengths_local = obj.cc_lengths;
% Find the length of each side.
%--------------------------------------------------------------------------
if head_I > tail_I
    size_1 = cc_lengths_local(head_I) - cc_lengths_local(tail_I);
    size_2 = cc_lengths_local(end)    - cc_lengths_local(head_I) + cc_lengths_local(tail_I);
else
    size_1 = cc_lengths_local(tail_I) - cc_lengths_local(head_I);
    size_2 = cc_lengths_local(end)    - cc_lengths_local(tail_I) + cc_lengths_local(head_I);
end

% Are the sides within 50% of each others size?
% Note: if a worm's length from head to tail is at least twice larger
% on one side (relative to the other), than the worm must be touching
% itself.
if min(size_1, size_2)/ max(size_1, size_2) <= .5
    obj.parse_error = true;
    obj.error_num   = 106;
    obj.error_msg   = ['The worm length, from head to tail, is more than ' ...
        'twice as large on one side than it is on the other. ' ...
        'Therefore, the worm is coiled or obscured and cannot be segmented.'];
    return;
end


%helper__getHeadTailMain(obj,lf_max_peaks,hf_max_peaks,lf_max_peaks_I,hf_max_peaks_I)

% Orient the contour and angles at the maximum curvature (the head or tail).
if head_I > 1
    %???? Why would head_I be at 1, what about our contour parsing makes
    %this likely
    %IMPORTANT: This redefines properties
    helper__headTailPropSwitch(obj);
end



end

function [head_I,tail_I] = helper__getHeadTailByLF(obj,lf_HT_max_peaks,lf_HT_I,hf_HT_I)

    cc_lengths_local = obj.cc_lengths;

    % Find the head and tail convexities in the low-frequency sampling.
    % Note: the tail should have a sharper angle.
    
    if lf_HT_max_peaks(1) <= lf_HT_max_peaks(2)
        lf_head_I = lf_HT_I(1);
        lf_tail_I = lf_HT_I(2);
    else
        lf_head_I = lf_HT_I(2);
        lf_tail_I = lf_HT_I(1);
    end
    
    % Localize the head by finding its nearest, sharpest (but blurred),
    % high-frequency convexity.
    %
    %i.e.
    %Find the closest hf_HT_I to lf_head_I
    %NOTE: The distance could be closest by "left (wrap around)" or "right"

        
    [~, temp_I] = min(helper_getMinCCDistance(cc_lengths_local,lf_head_I,hf_HT_I));
    head_I      = hf_HT_I(temp_I);
    
    % Localize the tail by finding its nearest, sharpest (but blurred),
    % high-frequency convexity.
    [~, temp_I] = min(helper_getMinCCDistance(cc_lengths_local,lf_tail_I,hf_HT_I));
    tail_I      = hf_HT_I(temp_I);
end

function [head_I,tail_I] = helper__getHeadTailByHF(hf_HT_max_peaks,hf_HT_I)

    % Find the head and tail convexities in the high-frequency sampling.
    % Note: the tail should have a sharper angle.
    if hf_HT_max_peaks(1) <= hf_HT_max_peaks(2)
        head_I = hf_HT_I(1);
        tail_I = hf_HT_I(2);
    else
        head_I = hf_HT_I(2);
        tail_I = hf_HT_I(1);
    end

end

function [head_I,tail_I] = helper__getHeadTailByManyHF(obj,hf_HT_max_peaks,hf_HT_I)

    cc_lengths_local = obj.cc_lengths;

    n_peaks = length(hf_HT_max_peaks);
    combos  = nchoosek(1:n_peaks,2);
    
    dist_all = arrayfun(@(x,y) helper_getMinCCDistance(cc_lengths_local,...
        hf_HT_I(combos(:,1)),hf_HT_I(combos(:,2))));
    
    keyboard
    
% % %     % Initialize our head and tail choicse.
% % %     hf_HT_I1 = hf_HT_I(1);
% % %     hf_HT_I2 = hf_HT_I(2);
% % %     
% % %     % How far apart are the head and tail?
% % %     dmhfHTI12 = abs(cc_lengths_local(hf_HT_I(1)) - cc_lengths_local(hf_HT_I(2)));
% % %     dmhfHTI12 = min(dmhfHTI12, cc_lengths_local(end) - dmhfHTI12);
% % %     
% % %     % Search for the 2 sharp convexities that are furthest apart.
% % %     for i = 1:(hf_HT_size - 1)
% % %         for j = (i + 1):hf_HT_size
% % %             
% % %             % How far apart are these 2 convexities?
% % %             dmhfHTIij = abs(cc_lengths_local(hf_HT_I(i)) - ...
% % %                 cc_lengths_local(hf_HT_I(j)));
% % %             dmhfHTIij = min(dmhfHTIij, cc_lengths_local(end) - dmhfHTIij);
% % %             
% % %             % These 2 convexities are better head and tail choices.
% % %             if dmhfHTIij > dmhfHTI12
% % %                 hf_HT_I1 = hf_HT_I(i);
% % %                 hf_HT_I2 = hf_HT_I(j);
% % %                 dmhfHTI12 = dmhfHTIij;
% % %             end
% % %         end
% % %     end
    
    % Which convexity is the head and which is the tail?
    % Note: the tail should have a sharper angle.
    if hf_HT_max_peaks(hf_HT_I1) < hf_HT_max_peaks(hf_HT_I2)
        head_I = hf_HT_I1;
        tail_I = hf_HT_I2;
    else
        head_I = hf_HT_I2;
        tail_I = hf_HT_I1;
    end
end

function helper__headTailPropSwitch(obj)
%
%
%   This occurs if head_I is not the first pixel


head_I_local = obj.head_I;

props_flip = {'lf_angles' 'hf_angles_raw' 'hf_angles_smoothed' 'rough_pixels' 'cleaned_pixels'};
for iProp = 1:length(props_flip)
   cur_prop = props_flip{iProp};
   cur_prop_value = obj.(cur_prop);
   obj.(cur_prop) = [cur_prop_value(head_I_local:end,:); cur_prop_value(1:(head_I_local - 1),:)];
end

%This one is different because of the circular nature
cc_lengths_local = obj.cc_lengths;
obj.cc_lengths = [...
    cc_lengths_local(head_I_local:end) - cc_lengths_local(head_I_local - 1); ...
    cc_lengths_local(1:(head_I_local - 1)) + ...
    (cc_lengths_local(end) - cc_lengths_local(head_I_local - 1))];

%This would look nicer, but the above is fine
%obj.cc_lengths = seg_worm.cv.circComputeChainCodeLengths(obj.cleaned_pixels);

tail_I_local = obj.tail_I;
tail_I_local = tail_I_local - head_I_local + 1;
if tail_I_local < 1
   tail_I_local = tail_I_local + size(contour_obj, 1);
end
obj.head_I = 1;
obj.tail_I = tail_I_local;

end

function min_dist = helper_getMinCCDistance(cc_lengths_local,index1,index_or_indices)
%
%   min_dist = helper_getMinCCDistance(cc_lengths_local,index1,index_or_indices)
%
%   NOTE: index1 and index_or_indices both index into cc_lengths_local

    %Get's the distance between two points, taking into account the
    %circular nature of the location and that you could go one way or the
    %other to get from one point to the other
    dRight   = abs(cc_lengths_local(index1) - cc_lengths_local(index_or_indices));
    dLeft    = cc_lengths_local(end) - dRight;
    min_dist = min(dRight,dLeft);
end
